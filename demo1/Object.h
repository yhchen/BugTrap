#include "StdAfx.h"
#include <assert.h>
#include <intrin.h>
#include <Windows.h>
#include <WinBase.h>
//#include <..\crt\src\utils.h>


#ifndef __SG2D_OBJECT_H__
#define __SG2D_OBJECT_H__

/**
* 基础对象类，所有SG2D对象的基类。
* 基础类具有引用计数，当对象的引用计数为0时对象会销毁自身。
* 当保存对象指针后通过调用retain增加对象引用计数；删除对象
* 指针引用后使用release减少对象引用计数。
*/
class Object
{
private:
	//引用计数，最高位表示删除标记，当对象正在被销毁时最高位会被置1，其余31位表示实际引用计数。
	//使用引用计数管理对象生命期存在一个需要处理的特殊情形：对象因为引用计数为0而需要被删除，此
	//时在对象的析构函数中可能还会引起此对象被增加和减少引用，当对一个正在销毁的对象增加引用并
	//减少引用时，根据引用计数管理对象生命期原则，release函数会判断递减引用后对象应该销毁，则
	//会再次发起对对象的销毁操作，导致此对象被销毁多次。因此，为避免这种特别的情况发生，必须能够
	//识别出对象是否正在销毁从而正在递减引用计数时进行检测识别并避免多次销毁对象的操作。因此将对
	//象引用计数成员的最高位用于做这个特殊的“正在销毁”的标记。
	unsigned int m_nRefer;
#ifdef _DEBUG
	unsigned int m_nCheckRelease;	// 设置是否检查动态释放
#endif // _DEBUG

public:
	Object()
	{
		m_nRefer = 1;
#ifdef _DEBUG
		m_nCheckRelease = 0;
#endif // _DEBUG
	}
	virtual ~Object()
	{
#ifdef _DEBUG
		if (m_nCheckRelease && m_nRefer != 0x80000000)
		{
			assert(false);
		}
#endif // _DEBUG
	}
	//获取引用计数
	inline int getRefer()
	{
		return _InterlockedAnd((long*)&m_nRefer, 0x7FFFFFFF);
	}

	//设置是否释放检查
#ifdef _DEBUG
	inline void setCheckRelease(bool val) { m_nCheckRelease = val; }
#else
	inline void setCheckRelease(bool val) { }
#endif // _DEBUG

	//增加引用
	inline int retain()
	{
		// #ifdef _DEBUG
		// 			m_nCheckRelease = 1;	//有调用retain的对象默认设置CheckRelease
		// #endif // _DEBUG
		return InterlockedIncrement((long*)&m_nRefer) & 0x7FFFFFFF;
	}
	//取消引用，当对象引用值为0时将销毁自身
	inline int release()
	{
#ifdef _DEBUG
		assert((m_nRefer & 0x7FFFFFFF) > 0);
#endif
		unsigned int ret = InterlockedDecrement(&m_nRefer);
		if (ret == 0)
		{
			return _InterlockedOr((long*)&m_nRefer, 0x80000000);
			delete this;
		}
		return ret & 0x7FFFFFFF;
	}

	//对象是否正在析构中 
	inline bool destroying()
	{
		return (m_nRefer & 0x80000000) != 0;
	}
};

typedef void (Object::*ObjectFunction)();

//将任何类型的类成员函数转换为地址指针的编译器欺骗函数
template <typename class_fn>
inline ObjectFunction objfnptr(class_fn fn)
{
	union { class_fn fn; ObjectFunction objFn; } u = { 0 };
	u.fn = fn;
	return u.objFn;
}

//将任何函数转换为地址指针的编译器欺骗函数
template <typename any_fn>
inline void* fnptr(any_fn fn)
{
	union { any_fn fn; void* ptr; } u = { 0 };
	u.fn = fn;
	return u.ptr;
}

#endif